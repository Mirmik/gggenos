#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"

#include <stdio.h>
#include <string.h>
#include <socket.h>	// Just include one header for WIZCHIP
#include <spi.h>

void delay_ms(uint32_t ms) {
	volatile uint32_t nCount;
	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq (&RCC_Clocks);
    nCount = (RCC_Clocks.HCLK_Frequency/10000)*ms;
    for (; nCount != 0; nCount--);
}


////////////////////////////////////////////////
// Shared Buffer Definition for LOOPBACK TEST //
////////////////////////////////////////////////
#define DATA_BUF_SIZE   2048
uint8_t gDATABUF[DATA_BUF_SIZE];

///////////////////////////////////
// Default Network Configuration //
///////////////////////////////////
wiz_NetInfo gWIZNETINFO = { .mac = {0x00, 0x08, 0xdc,0x00, 0xab, 0xcd},
                            .ip = {192, 168, 1, 25},
                            .sn = {255,255,255,0},
                            .gw = {192, 168, 1, 1},
                            .dns = {0,0,0,0},
                            .dhcp = NETINFO_STATIC };


// initialize the dependent host peripheral
void platform_init(void);

//////////////////////////////////////////////////////////////////////////////////////////////
// Call back function for W5500 SPI - Theses used as parameter of reg_wizchip_xxx_cbfunc()  //
// Should be implemented by WIZCHIP users because host is dependent                         //
//////////////////////////////////////////////////////////////////////////////////////////////
void  wizchip_select(void);
void  wizchip_deselect(void);
void  wizchip_write(uint8_t wb);
uint8_t wizchip_read();
//////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////
// For example of ioLibrary_BSD //
//////////////////////////////////
void network_init(void);								// Initialize Network information and display it
int32_t tcp_http_mt(uint8_t, uint8_t*, uint16_t);		// Multythread TCP server
void HTTP_reset(uint8_t sockn);
//////////////////////////////////


//states for multythread http
#define HTTP_IDLE 0
#define HTTP_SENDING 1

//variables for multythread http
uint32_t sentsize[_WIZCHIP_SOCK_NUM_];
uint8_t http_state[_WIZCHIP_SOCK_NUM_];

int main(void)
{
   uint8_t i;
   uint8_t phy_l;
   uint8_t memsize[2][8] = {{2,2,2,2,2,2,2,2},{2,2,2,2,2,2,2,2}};

   ///////////////////////////////////////////
   // Host dependent peripheral initialized //
   ///////////////////////////////////////////

   platform_init();

   ////////////////////////////////////////////////////////////////////////////////////////////////////
   // First of all, Should register SPI callback functions implemented by user for accessing WIZCHIP //
   ////////////////////////////////////////////////////////////////////////////////////////////////////

   /* Chip selection call back */

#if   _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_
    reg_wizchip_cs_cbfunc(wizchip_select, wizchip_deselect);
#elif _WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_FDM_
    reg_wizchip_cs_cbfunc(wizchip_select, wizchip_select);  // CS must be tried with LOW.
#else
   #if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SIP_) != _WIZCHIP_IO_MODE_SIP_
      #error "Unknown _WIZCHIP_IO_MODE_"
   #else
      reg_wizchip_cs_cbfunc(wizchip_select, wizchip_deselect);
   #endif
#endif


    //delay_ms(150);          //  без этой задержки почему то не стартует сервер после отключения питания

     /* SPI Read & Write callback function */
    reg_wizchip_spi_cbfunc(wizchip_read, wizchip_write);

    ////////////////////////////////////////////////////////////////////////

    /* WIZCHIP SOCKET Buffer initialize */
    if(ctlwizchip(CW_INIT_WIZCHIP,(void*)memsize) == -1)
    {
       //init fail
       while(1);
    }

    //while(ctlwizchip(CW_GET_PHYLINK, (void*)&phy_l) != PHY_LINK_ON);   // ждем установления коннекта



    /* PHY link status check */
        do
        {
           ctlwizchip(CW_GET_PHYLINK, (void*)&phy_l);
        }while(phy_l != PHY_LINK_ON);





    /* Network initialization */
    network_init();

    //all connections inactive
    for(i=0;i<_WIZCHIP_SOCK_NUM_;i++)
    {
    	HTTP_reset(i);
    }

    /* Main loop */
    while(1)
	{
    	// TCP server
    	for(i=0;i<_WIZCHIP_SOCK_NUM_;i++)
    	tcp_http_mt(i, gDATABUF, 80);

	}

    // end of Main loop
} // end of main()


/////////////////////////////////////////////////////////////////
// SPI Callback function for accessing WIZCHIP                 //
// WIZCHIP user should implement with your host spi peripheral //
/////////////////////////////////////////////////////////////////
void  wizchip_select(void)
{
	W5500_select();
}

void  wizchip_deselect(void)
{
	W5500_release();
}

void  wizchip_write(uint8_t wb)
{
	W5500_tx(wb);
}

uint8_t wizchip_read()
{
   return W5500_rx();
}
//////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////
// Intialize the network information to be used in WIZCHIP //
/////////////////////////////////////////////////////////////
void network_init(void)
{
   uint8_t tmpstr[6];

	ctlnetwork(CN_SET_NETINFO, (void*)&gWIZNETINFO);

	ctlwizchip(CW_GET_ID,(void*)tmpstr);
}
/////////////////////////////////////////////////////////////


const char ICON [1150] = {0x00,0x00,0x01,0x00,0x01,0x00,0x10,0x10,0x00,0x00,0x01,0x00,0x20,0x00,0x68,0x04,0x00,0x00,0x16,
		              0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x01,0x00,0x20,0x00,
		              0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x12,0x0B,0x00,0x00,0x12,0x0B,0x00,0x00,0x00,0x00,0x00,
		              0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,
		              0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x3F,0x34,0x28,0xFF,0x3F,0x34,0x28,0xFF,0x3F,
		              0x34,0x28,0xFF,0x3F,0x34,0x28,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,
		              0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,
		              0x00,0xFF,0xFF,0xFF,0x00,0x3F,0x34,0x28,0xFF,0x3F,0x34,0x28,0xFF,0xFF,0xFF,0xFF,0x00,0x77,0x6D,
		              0x66,0xFF,0xE5,0xDB,0xD2,0xFF,0xE5,0xDB,0xD2,0xFF,0x77,0x6D,0x66,0xFF,0xFF,0xFF,0xFF,0x00,0x3F,
		              0x34,0x28,0xFF,0x3F,0x34,0x28,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,
		              0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x3F,0x34,0x28,0xFF,0x87,0x7D,0x73,0xFF,0xE1,0xD9,0xD1,
		              0xFF,0x57,0x4D,0x42,0xFF,0x76,0x6C,0x63,0xFF,0xED,0xE5,0xDD,0xFF,0xED,0xE5,0xDD,0xFF,0x76,0x6C,
		              0x63,0xFF,0x57,0x4D,0x42,0xFF,0xE1,0xD9,0xD1,0xFF,0x87,0x7D,0x73,0xFF,0x3F,0x34,0x28,0xFF,0xFF,
		              0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x3F,0x34,0x28,0xFF,0xB6,0xB0,0xA9,0xFF,
		              0xE1,0xD9,0xD1,0xFF,0xC8,0xBE,0xB4,0xFF,0xE1,0xD9,0xD1,0xFF,0xC8,0xBE,0xB4,0xFF,0xED,0xE5,0xDD,
		              0xFF,0xED,0xE5,0xDD,0xFF,0xC8,0xBE,0xB4,0xFF,0xE1,0xD9,0xD1,0xFF,0xC8,0xBE,0xB4,0xFF,0xE1,0xD9,
		              0xD1,0xFF,0xB6,0xB0,0xA9,0xFF,0x3F,0x34,0x28,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x3F,
		              0x34,0x28,0xFF,0xE1,0xD9,0xD1,0xFF,0xEB,0xE7,0xE3,0xFF,0xE1,0xD9,0xD1,0xFF,0xAE,0xA7,0xA0,0xFF,
		              0xE2,0xDD,0xDA,0xFF,0xB7,0xB1,0xAB,0xFF,0xB7,0xB1,0xAB,0xFF,0xE2,0xDD,0xDA,0xFF,0xAE,0xA7,0xA0,
		              0xFF,0xE1,0xD9,0xD1,0xFF,0xEB,0xE7,0xE3,0xFF,0xE1,0xD9,0xD1,0xFF,0x3F,0x34,0x28,0xFF,0xFF,0xFF,
		              0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x61,0x56,0x4C,0xFF,0xE1,0xD9,0xD1,0xFF,0xAC,
		              0xA3,0x9B,0xFF,0xE4,0xE1,0xDC,0xFF,0xAF,0xA8,0xA4,0xFF,0x69,0x5E,0x53,0xFF,0x69,0x5E,0x53,0xFF,
		              0xAF,0xA8,0xA4,0xFF,0xE4,0xE1,0xDC,0xFF,0xAC,0xA3,0x9B,0xFF,0xE1,0xD9,0xD1,0xFF,0x61,0x56,0x4C,
		              0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x46,0x3B,0x2F,0xFF,0x3E,0x33,0x28,0xFF,0x61,0x56,
		              0x4C,0xFF,0xAF,0xA8,0xA4,0xFF,0xC1,0xBC,0xB6,0xFF,0xAF,0xA8,0xA4,0xFF,0x69,0x5E,0x53,0xFF,0xFF,
		              0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x69,0x5E,0x53,0xFF,0xAF,0xA8,0xA4,0xFF,0xC1,0xBC,0xB6,0xFF,
		              0xAF,0xA8,0xA4,0xFF,0x61,0x56,0x4C,0xFF,0x3E,0x33,0x28,0xFF,0x46,0x3B,0x2F,0xFF,0x89,0x7E,0x74,
		              0xFF,0xE8,0xE0,0xD7,0xFF,0xE8,0xE0,0xD7,0xFF,0xB0,0xAC,0xA8,0xFF,0xE8,0xE3,0xDD,0xFF,0x69,0x5E,
		              0x53,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x69,
		              0x5E,0x53,0xFF,0xE8,0xE3,0xDD,0xFF,0xB0,0xAC,0xA8,0xFF,0xE8,0xE0,0xD7,0xFF,0xE8,0xE0,0xD7,0xFF,
		              0x89,0x7E,0x74,0xFF,0x87,0x7B,0x70,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xBF,0xBC,0xB8,
		              0xFF,0xD6,0xCD,0xC5,0xFF,0x69,0x5E,0x53,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		              0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x69,0x5E,0x53,0xFF,0xD6,0xCD,0xC5,0xFF,0xBF,0xBC,0xB8,0xFF,0xFF,
		              0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0x7B,0x70,0xFF,0x8E,0x83,0x78,0xFF,0x89,0x7D,0x72,0xFF,
		              0x84,0x79,0x6C,0xFF,0xD8,0xD5,0xD3,0xFF,0xC9,0xC2,0xB9,0xFF,0xA9,0x9C,0x90,0xFF,0x59,0x4F,0x45,
		              0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x60,0x56,0x4D,0xFF,0xA9,0x9C,0x90,0xFF,0xC9,0xC2,
		              0xB9,0xFF,0xD8,0xD5,0xD3,0xFF,0x84,0x79,0x6C,0xFF,0x89,0x7D,0x72,0xFF,0x8E,0x83,0x78,0xFF,0xFF,
		              0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x69,0x60,0x53,0xFF,0xDF,0xDF,0xDE,0xFF,0xDF,0xDF,0xDE,0xFF,
		              0xD1,0xC4,0xBA,0xFF,0x8E,0x83,0x77,0xFF,0x44,0x39,0x2E,0xFF,0x44,0x39,0x2E,0xFF,0x8E,0x83,0x77,
		              0xFF,0xD1,0xC4,0xBA,0xFF,0xDF,0xDF,0xDE,0xFF,0xDF,0xDF,0xDE,0xFF,0x69,0x60,0x53,0xFF,0xFF,0xFF,
		              0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x69,0x60,0x53,0xFF,0xF6,0xF1,0xEE,0xFF,0xBB,
		              0xAC,0x9D,0xFF,0xDF,0xD8,0xD3,0xFF,0xEE,0xEF,0xEF,0xFF,0xEB,0xE7,0xE2,0xFF,0xE3,0xD9,0xD1,0xFF,
		              0xE3,0xD9,0xD1,0xFF,0xEB,0xE7,0xE2,0xFF,0xEE,0xEF,0xEF,0xFF,0xDF,0xD8,0xD3,0xFF,0xBB,0xAC,0x9D,
		              0xFF,0xF6,0xF1,0xEE,0xFF,0x69,0x60,0x53,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x67,0x5D,
		              0x50,0xFF,0xCD,0xC6,0xBF,0xFF,0xF6,0xF1,0xEE,0xFF,0xF8,0xF7,0xF4,0xFF,0xF8,0xF7,0xF4,0xFF,0xFF,
		              0xFF,0xFF,0xFF,0xFC,0xFD,0xFD,0xFF,0xFC,0xFD,0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xF7,0xF4,0xFF,
		              0xF8,0xF7,0xF4,0xFF,0xF6,0xF1,0xEE,0xFF,0xCD,0xC6,0xBF,0xFF,0x69,0x60,0x53,0xFF,0xFF,0xFF,0xFF,
		              0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x99,0x8F,0x83,0xFF,0xCC,0xC5,0xBE,0xFF,0xF6,0xF1,
		              0xEE,0xFF,0x90,0x83,0x77,0xFF,0x90,0x83,0x77,0xFF,0xED,0xE7,0xE0,0xFF,0xED,0xE7,0xE0,0xFF,0x90,
		              0x83,0x77,0xFF,0x90,0x83,0x77,0xFF,0xF6,0xF1,0xEE,0xFF,0xCC,0xC5,0xBE,0xFF,0xA9,0xA0,0x96,0xFF,
		              0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,
		              0x00,0x9C,0x90,0x83,0xFF,0x9C,0x90,0x83,0xFF,0xFF,0xFF,0xFF,0x00,0x99,0x8D,0x80,0xFF,0xFF,0xFF,
		              0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0x8D,0x80,0xFF,0xFF,0xFF,0xFF,0x00,0x9C,0x90,0x83,0xFF,0x9C,
		              0x90,0x83,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,
		              0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,
		              0x00,0xA1,0x95,0x88,0xFF,0x9C,0x90,0x83,0xFF,0x9C,0x90,0x83,0xFF,0xA1,0x95,0x88,0xFF,0xFF,0xFF,
		              0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,
		              0xFF,0xFF,0x00,0xFC,0x3F,0x00,0x00,0xE4,0x27,0x00,0x00,0xC0,0x03,0x00,0x00,0x80,0x01,0x00,0x00,
		              0x80,0x01,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		              0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x80,0x01,0x00,0x00,0x80,0x01,0x00,0x00,0xC0,0x03,
		              0x00,0x00,0xE4,0x27,0x00,0x00,0xFC,0x3F,0x00,0x00
};

const char Img [205] =
{
0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A,0x00,0x00,0x00,0x0D,0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x05,
0x00,0x00,0x00,0x05,0x08,0x02,0x00,0x00,0x00,0x02,0x0D,0xB1,0xB2,0x00,0x00,0x00,0x01,0x73,0x52,0x47,
0x42,0x00,0xAE,0xCE,0x1C,0xE9,0x00,0x00,0x00,0x06,0x62,0x4B,0x47,0x44,0x00,0xFF,0x00,0xFF,0x00,0xFF,
0xA0,0xBD,0xA7,0x93,0x00,0x00,0x00,0x09,0x70,0x48,0x59,0x73,0x00,0x00,0x0B,0x13,0x00,0x00,0x0B,0x13,
0x01,0x00,0x9A,0x9C,0x18,0x00,0x00,0x00,0x07,0x74,0x49,0x4D,0x45,0x07,0xDF,0x05,0x0A,0x0E,0x01,0x20,
0xA0,0x0A,0x57,0xCD,0x00,0x00,0x00,0x19,0x74,0x45,0x58,0x74,0x43,0x6F,0x6D,0x6D,0x65,0x6E,0x74,0x00,
0x43,0x72,0x65,0x61,0x74,0x65,0x64,0x20,0x77,0x69,0x74,0x68,0x20,0x47,0x49,0x4D,0x50,0x57,0x81,0x0E,
0x17,0x00,0x00,0x00,0x28,0x49,0x44,0x41,0x54,0x08,0xD7,0x4D,0x8B,0x41,0x0E,0x00,0x30,0x08,0xC2,0xA8,
0xFF,0xFF,0x73,0x3D,0x18,0xDD,0xB8,0x34,0x94,0x40,0x12,0x35,0x9B,0x52,0x81,0xD7,0x67,0x3F,0x55,0x83,
0x53,0xFC,0x67,0xA0,0x01,0x8E,0xCE,0x0F,0x06,0x6E,0x28,0x44,0x78,0x00,0x00,0x00,0x00,0x49,0x45,0x4E,
0x44,0xAE,0x42,0x60,0x82
};

const char site[] =
        "<html>"
		"<head>"
		"<title>Умный дом</title>"
		"<meta http-equiv='content-type' content='text/html; charset=windows-1251'>"
        "</head>"
		"<body>"
		"<br><br><br><center><b>Тестовая страница W5500</b></center><br>"
		"<center><img src='test.png'></center>"
		"</body>"
		"</html>";

const char http_404_full[] =
	"HTTP/1.0 404 Not Found\r\n"
	"Content-Type: text/html;"
	"Server: STM32+W5500\r\n"
	"\r\n"
	"<pre>Page not found\r\n\r\n";

const char  http_200[] = "HTTP/1.1 200 OK\r\n";
const char http_server[] = "Server: Home\r\n";
const char http_connection_close[] = "Connection: close\r\n";
const char  http_header_end[] = "\r\n";
const char http_not_found[] = "<h1>404 - Not Found</h1>";

/*
const char http_text_plain[] = "text/plain";
const char http_text_html[] = "text/html";
const char http_text_js[] = "text/javascript";
const char  http_text_css[] = "text/css";
const char http_image_gif[] = "image/gif";
const char http_image_png[] = "image/png";
const char  http_image_jpeg[] = "image/jpeg";
const char  http_video_mp4[] = "video/mp4";
const char  http_video_avi[] = "video/avi";
*/


// get mime type from filename extension
/*
const char *httpd_get_mime_type(char *url)
{
	const char *t_type;
	char *ext;

     t_type = http_text_plain;

	if((ext = strrchr(url, '.')))
	{
		ext++;
		strlwr(ext);

	    if(strcmp(ext, "txt")==0)
		t_type = http_text_plain;

	    else if(strcmp(ext, "htm")==0)
		t_type = http_text_html;

	    else if(strcmp(ext, "html")==0)
		t_type = http_text_html;

	    else if(strcmp(ext, "js")==0)
		t_type = http_text_js;

	    else if(strcmp(ext, "css")==0)
		t_type = http_text_css;

	    else if(strcmp(ext, "gif")==0)
		t_type = http_image_gif;

	    else if(strcmp(ext, "png")==0)
		t_type = http_image_png;

	    else if(strcmp(ext, "jpg")==0)
		t_type = http_image_jpeg;

	    else if(strcmp(ext, "jpeg")==0)
		t_type = http_image_jpeg;

	    else if(strcmp(ext, "mp4")==0)
		t_type = http_video_mp4;

	    else if(strcmp(ext, "avi")==0)
		t_type = http_video_avi;

	}

	return t_type;
}
*/

//http server

void HTTP_reset(uint8_t sockn)
{
    sentsize[sockn]=0;
	http_state[sockn]=HTTP_IDLE;
}


int32_t tcp_http_mt(uint8_t sn, uint8_t* buf, uint16_t port)
{
   int32_t ret;
   uint32_t size = 0;
   char *url,*p;

   switch(getSn_SR(sn))
   {
      case SOCK_ESTABLISHED :

         if(getSn_IR(sn) & Sn_IR_CON)
         {
            setSn_IR(sn,Sn_IR_CON);
         }

         if((size = getSn_RX_RSR(sn)) > 0)
         {
            if(size > DATA_BUF_SIZE)
            {
            	size = DATA_BUF_SIZE;
            }

            ret = recv(sn,buf,size);

            HTTP_reset(sn);

            if(ret <= 0)
            {
            	return ret;
            }

            url =(char*) buf + 4;

            if((http_state[sn]==HTTP_IDLE)&&(memcmp(buf, "GET ", 4)==0)&&((p = strchr(url, ' '))))  // extract URL from request header
            {
              *(p++) = 0;   //making zeroed url string

              sentsize[sn]=0;

              if(strcmp(url,"/")==0)
              {
                strcpy((char*)buf,http_200);
                strcat((char*)buf, http_server);
                strcat((char*)buf,"Content-Type: text/html; charset=windows-1251\r\n");
                strcat((char*)buf,"Cache-Control: no-cache\r\n");
                strcat((char*)buf,http_connection_close);
                strcat((char*)buf, http_header_end);
                strcat((char*)buf,site);
                size=strlen((char*)buf);
                http_state[sn]=HTTP_SENDING;
              }

              if(strcmp(url,"/test.png")==0)
                            {
                              strcpy((char*)buf,http_200);
                              strcat((char*)buf, http_server);
                              strcat((char*)buf,"Content-Type: image/png\r\n");
                              //strcat((char*)buf,"Content-Disposition: attachment; filename=default-download-filename.png\r\n");
                              strcat((char*)buf,"Content-Lenght: 205\r\n");
                              strcat((char*)buf,"Connection: keep-alive\r\n");
                              strcat((char*)buf,"Keep-Alive: timeout=20\r\n");
                              strcat((char*)buf,"Accept-Ranges: bytes\r\n");
                              strcat((char*)buf,"Cache-Control: no-cache\r\n");
                              strcat((char*)buf, http_header_end);
                              strcat((char*)buf,Img);
                              size=strlen((char*)buf);
                              http_state[sn]=HTTP_SENDING;
                            }
            }

/*
           Отправляем данные пока размер отправленных данных sentsize[sn] не сравняется с размером данных size
           которые мы подготовили для отправки
*/
           if(http_state[sn]==HTTP_SENDING)
            {
        	   while (sentsize[sn] < size)
        	   {
        		  //DATA_BUF_SIZE

        		ret = send(sn,buf,size);
        	    if(ret < 0)
        	    {
        	     close(sn);
        	     return ret;
        	    }
        	    sentsize[sn] += ret; // Don't care SOCKERR_BUSY, because it is zero.
        	   }
        	  HTTP_reset(sn);
        	  disconnect(sn);
            }
          }

         break;

      case SOCK_CLOSE_WAIT :

    	  HTTP_reset(sn);

         if((ret=disconnect(sn)) != SOCK_OK)
         return ret;

         break;
      case SOCK_INIT :

    	  HTTP_reset(sn);

         if( (ret = listen(sn)) != SOCK_OK) return ret;
         break;
      case SOCK_CLOSED:

    	  HTTP_reset(sn);

         if((ret=socket(sn,Sn_MR_TCP,port,0x00)) != sn)
         return ret;

         break;

      default:
    	  HTTP_reset(sn);
         break;
   }
   return 1;
}



//////////////////////////////////////////////////////////////////////////////
// Platform (STM32F103X) initialization for peripherals as GPIO, SPI, UARTs //
//////////////////////////////////////////////////////////////////////////////
void platform_init(void)
{
	spiW5500_init();

}
