#!/usr/bin/env ruby
#doding: utf-8

require 'colorize'

class Modules
	class << self
		attr_accessor :modules, :applications

		def initialize
			@modules = []
			@applications = []
		end

		def print_names
			@modules.each {|m| puts m.name}
		end
	end
end

class Module
	attr_accessor :source, :depend, :mdepend, :name, :relpath, :options, :target, :incl, :pack

	def initialize
		@relpath = $relpath
		#@name = std_name
		#@depend = $std_depend
		#@mdepend = $std_mdepend
		#@source = $std_source
	end

	def to_s
		puts "Module:"
		puts "name: %s" % @name.to_s
		puts "source: %s" % @source.to_s
		puts "depend: %s" % @depend.to_s
		puts "mdepend: %s" % @mdepend.to_s
		puts "relpath: %s" % @relpath.to_s
		puts "options: %s" % @options.to_s
		puts "pack: %s" % @pack.to_s
		puts "incl: %s" % @incl.to_s
		puts "target: %s" % @target.to_s
		
	end
end

class CModules
	attr_accessor :mods, :fmodules

	def initialize
		@mods = []
		@fmodules = {}
	end

	def to_s
		mods.each {|m| puts m}
	end
end 

class Application
	attr_accessor :name, :modules, :main, :relpath, :target

	def initialize
		
	end

	def to_s
		puts "Application:"
		puts "name: %s" % @name.to_s
		puts "modules: %s" % @modules.to_s
		puts "main: %s" % @main.to_s
	end
end



def init_var
	$name = $std_name
	$options = $std_options
	$depend = $std_depend
	$mdepend = $std_mdepend
	$source = $std_source
	$target = $std_target
	$pack = $std_pack
	$incl = []
	$main = $std_main
	$modules = []
end

def declare_module 
	mod = Module.new
	mod.source = $source
	mod.depend = $depend
	mod.mdepend = $mdepend
	mod.options = $options
	mod.name = $name
	mod.target = $target
	mod.pack = $pack
	mod.incl = $incl
	Modules.modules.push mod
	init_var
end


def declare_application
	app = Application.new
	app.name = $name	
	app.modules = $modules	
	app.relpath = $relpath	
	app.main = $main	
	app.target = $target
	Modules.applications.push app
	init_var
end 

def target_path(mod)
	'build/' + mod.relpath + mod.target
end

require "fileutils"
def compile(mod)
	#print mod
	$OPTIONS = ""
	mod[1].each {|k, v| $OPTIONS = $OPTIONS + " -D%s=%s" % [k, v]}

	mod[0].source.each { |s|


		if s.index(/.cpp$/) != nil
		then
			$SOURCE = mod[0].relpath + s
			$TARGET = "build/" + mod[0].relpath + s[0..-5] + ".o"
			puts cxx_rule	
			system( cxx_rule )
		elsif s.index(/.c$/) != nil
		then
			$SOURCE = mod[0].relpath + s
			$TARGET = "build/" + mod[0].relpath + s[0..-3] + ".o"
			puts cc_rule	
			system( cc_rule )
		end

		$TARGETS = $TARGETS + " %s" %  $TARGET
	}
	
	$SOURCE = $TARGETS
	$TARGET = mod[0].target
	
	puts 	ar_rule 
	system( ar_rule )

	$MTARGETS = $MTARGETS + " %s" % $TARGET

end











puts "RLINK script".green

Dir.chdir('.')

puts "Scanning %s file tree" % "src".yellow
hfiles = Dir['src/**/*']
puts "Scanning %s file tree" % "curprj".yellow
hfiles += Dir['curprj/**/*']

files = []
hfiles.each {|f| files << f if f.index(/\/*HIDE\/*/)==nil}
puts "Nohiden files in src : %s" % files.size.to_s.yellow


files.each { |f|  if FileTest.directory?(f) and not File.file?('build/' + f) then 
FileUtils.mkdir_p('build/' + f) end
}




declf = files.map {|f| if f.index(/\/*moddecl$/)!=nil then f else nil end}.compact
puts "Module decl files in src : %s" % declf.size.to_s.yellow


load "curprj/glbdecl"
init_var

Modules.initialize

#Обход дерева, выполнение скриптов moddecl
declf.each { |d|
	$relpath = d[0..-("moddecl".length + 1)] 
	puts "Loading moddecl: %s" %d.yellow
	load d
}

hmodules = {}
Modules.modules.each { |m| hmodules[m.name] = m}

Modules.applications.each { |app|
	cm = CModules.new 

	#Переименование модулей на основе имплементаций.
	app.modules.each { |m|
		if hmodules.has_key?(m[0])
			then cm.mods.push([hmodules[m[0]], m[2]])
		elsif hmodules.has_key?(m[1])
			then 
			mm = hmodules[m[1]]
			mm.name = m[0]
			cm.mods.push([mm, m[2]])
		else
			print "All bad".red
			exit
		end
	}

	def repack(hmodules, cm, m)
		print m[0]
		m[0].pack.each {|p| cm.mods.push([hmodules[p[0]], p[1]])}
	end

	cm.mods.each { |m| repack(hmodules, cm,m) }

	cm.mods.each { |m|	cm.fmodules[m[0].name] = [m, 0]	}


	#
	#
	#TODO Проверка зависимости. Вычисление потребности в компиляции.
	cm.fmodules.each_value {|m| m[1] = 1}
	#
	#
	#

	$INCLUDE = ""
	cm.fmodules.each_value {|mod|
		mod[0][0].incl.each {|i| $INCLUDE = $INCLUDE + " -I%s" % i}
	}
	$std_incl.each {|i| $INCLUDE = $INCLUDE + " -I%s" % i}


	$MTARGETS = ""
	cm.fmodules.each_value {|m|
		$TARGETS = ""
		if m[1] == 1 
			then
			compile(m[0])
		end
	}

	$SOURCE = $MTARGETS
	$TARGET = app.target

	print ld_rule
	system ( ld_rule )

	#File.cp($TARGET)
}